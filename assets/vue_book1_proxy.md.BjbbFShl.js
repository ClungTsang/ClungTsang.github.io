import{_ as i,c as a,b0 as e,o as n}from"./chunks/framework.D6xZgKGL.js";const c=JSON.parse('{"title":"vue3的响应式原理","description":"","frontmatter":{},"headers":[],"relativePath":"vue/book1_proxy.md","filePath":"vue/book1_proxy.md","lastUpdated":1690733455000}'),t={name:"vue/book1_proxy.md"};function p(l,s,h,k,o,d){return n(),a("div",null,s[0]||(s[0]=[e(`<h1 id="vue3的响应式原理" tabindex="-1">vue3的响应式原理 <a class="header-anchor" href="#vue3的响应式原理" aria-label="Permalink to &quot;vue3的响应式原理&quot;">​</a></h1><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>Vue 3 的响应式原理是通过使用 <code>Proxy</code> 对象来实现的。<code>Proxy</code> 是 ES6 中的一个特性，它可以拦截对对象的访问和操作，并在拦截过程中触发相应的操作。Vue 3 利用 <code>Proxy</code> 对象来监听数据的变化，并在数据变化时自动更新相关的视图。</p></div><p>下面是一个简单的代码演示，展示了 Vue 3 的响应式原理：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { reactive, watch } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;vue&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 创建一个响应式对象</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> state</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> reactive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  count: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 创建一个侦听器，当 count 发生变化时执行回调函数</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">watch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> state.count, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">newValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">oldValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`count 变化了：\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">oldValue</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">} -&gt; \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">newValue</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 修改 count 的值</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">state.count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出：count 变化了：0 -&gt; 1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">state.count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出：count 变化了：1 -&gt; 2</span></span></code></pre></div><p>在上面的代码中，我们首先使用 <code>reactive</code> 函数创建了一个响应式对象 <code>state</code>，它包含一个属性 <code>count</code>。然后，我们使用 <code>watch</code> 函数创建了一个侦听器，当 <code>count</code> 发生变化时，会执行回调函数并打印变化前后的值。</p><p>接下来，我们修改了 <code>state.count</code> 的值，这时会触发侦听器的回调函数，输出相应的变化信息。</p><p>Vue 3 的响应式原理通过 <code>Proxy</code> 对象拦截了对 <code>state</code> 对象的访问和操作，使得当我们修改 <code>state.count</code> 的值时，能够自动触发侦听器的回调函数。这使得我们无需手动跟踪数据的变化并手动更新视图，而是让 Vue 3 自动处理这些操作。</p><p>需要注意的是，Vue 3 的响应式原理不仅限于单个对象，还可以递归地监听对象的嵌套属性，以及数组的变化。这使得我们能够方便地处理复杂的数据结构，并实现高效的视图更新。</p><h1 id="vue3响应式和vue2响应式的区别是什么" tabindex="-1">vue3响应式和vue2响应式的区别是什么 <a class="header-anchor" href="#vue3响应式和vue2响应式的区别是什么" aria-label="Permalink to &quot;vue3响应式和vue2响应式的区别是什么&quot;">​</a></h1><p>Vue 3 的响应式原理相较于 Vue 2 有一些重要的区别，主要包括以下几点：</p><ol><li><p>基于 Proxy 对象：Vue 3 使用 Proxy 对象来实现响应式，而 Vue 2 使用 Object.defineProperty。Proxy 对象提供了更强大和灵活的拦截能力，能够监听更多类型的操作，包括属性的新增、删除和数组的变化等。相比之下，Object.defineProperty 只能监听属性的读取和赋值操作。</p></li><li><p>性能优化：Vue 3 的响应式系统经过重新设计，采用了更高效的追踪机制。Vue 3 能够在组件渲染过程中跟踪依赖，并将依赖关系进行标记，只更新受影响的部分，减少了不必要的更新开销。这使得 Vue 3 在性能方面相较于 Vue 2 有明显的提升。</p></li><li><p>Composition API：Vue 3 引入了 Composition API，它是一种基于函数的 API 风格，可以更好地组织和复用逻辑代码。Composition API 提供了更灵活的组合方式，使得代码更加可读、可维护，并且更好地支持 TypeScript。Vue 3 的响应式系统与 Composition API 紧密结合，使得在组合式开发中能够更好地利用响应式能力。</p></li></ol><p>这些区别带来了一些优势：</p><ol><li><p>更强大的响应式能力：Vue 3 的 Proxy-based 响应式系统能够监听更多类型的操作，包括属性的新增、删除和数组的变化等。这使得开发者能够更自由地操作数据，并且能够更准确地追踪数据变化。</p></li><li><p>更高的性能：Vue 3 在性能方面进行了优化，通过追踪依赖关系并只更新受影响的部分，减少了不必要的更新开销。这使得在大型应用中能够更高效地进行渲染和更新，提供更好的用户体验。</p></li><li><p>更灵活的组合式开发：Vue 3 的 Composition API 提供了更灵活的组合方式，使得代码更加可读、可维护，并且更好地支持 TypeScript。响应式系统与 Composition API 的结合，使得在组合式开发中能够更好地利用响应式能力，实现更高效的代码组织和复用。</p></li></ol><p>总而言之，Vue 3 的响应式原理相较于 Vue 2 在功能和性能方面都有所提升，能够提供更强大、高效和灵活的开发体验，使得开发者能够更好地构建复杂的应用程序。</p>`,14)]))}const E=i(t,[["render",p]]);export{c as __pageData,E as default};
