# 隐式转化引申的拓展问题
::: tip 
1、字符串和数字比较的时候，字符串先转换成数字。  
2、有布尔值参与比较的时候，布尔值先转换成数字。  
3、对象类型参与比较的时候，根据toPrimitive原则进行转换，具体为，先调用valueOf()，如果没有返回原始类型，则再调用toSting()返回原始类型
:::
##  [] == ![] 结果是什么

结果是 `true`。

这涉及到 JavaScript 中的隐式类型转换和运算符优先级的概念。

首先，`!` 是逻辑非运算符，它将操作数转换为布尔值并取反。对于非空数组 `[]` 来说，它被视为真值，所以 `![]` 的结果是 `false`。

然后，对于相等运算符 `==`，当操作数的类型不同时，会进行隐式类型转换。在这个表达式中，左操作数是一个空数组 `[]`，右操作数是一个布尔值 `false`。

在进行比较之前，JavaScript 会尝试将两个操作数转换为相同的类型。在这里，由于操作数类型不同，JavaScript 会将布尔值 `false` 转换为数字类型。在数字类型转换中，`false` 被转换为数字 `0`。

接下来，将两个操作数都转换为数字类型后，比较的表达式变为 `[] == 0`。

在比较数组和数字时，JavaScript 会将数组转换为字符串。因此，`[]` 被转换为空字符串 `""`。

现在，比较的表达式变为 `"" == 0`。

在比较字符串和数字时，JavaScript 会尝试将字符串转换为数字。由于 `""` 在转换为数字时无法得到有效的数字，它会被转换为 `0`。

最终，比较的表达式变为 `0 == 0`。

由于比较的操作数相等，所以最终的结果是 `true`。

这个结果可能会令人困惑，因为看起来一个空数组和布尔值 `false` 应该是不相等的。但是，在 JavaScript 中，隐式类型转换和运算符优先级会导致这样的结果。为了避免这种混淆，通常建议使用严格相等运算符 `===`，它不会进行类型转换，只有在操作数类型相同且值相等时才返回 `true`。

## 拓展阅读
1. [从一道面试题说起—js隐式转换踩坑合集](https://juejin.cn/post/6844903694039777288)